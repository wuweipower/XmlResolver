## 多态
虚函数表（Virtual Function Table）是在编译期创建的，而虚函数指针（Virtual Function Pointer）是在运行时创建的。

在编译期，当定义一个带有虚函数的类时，编译器会为该类创建一个虚函数表。虚函数表是一个静态的数据结构，其中存储了该类的虚函数的地址。每个类只有一个虚函数表，它在编译期就被创建，并与类的定义一起存储在可执行文件的数据段中。

在运行时，每个对象实例都包含一个指向其类的虚函数表的虚函数指针。虚函数指针是在对象创建时被设置的，它指向该对象所属的类的虚函数表。通过虚函数指针，可以在运行时动态地查找并调用正确的虚函数。

当使用基类指针或引用调用虚函数时，会在运行时通过虚函数指针和虚函数表来确定实际调用的函数。这个过程称为动态绑定或后期绑定，因为在运行时才确定调用哪个函数，而不是在编译期静态地绑定。

总结起来，虚函数表是在编译期创建的，它存储了类的虚函数的地址。虚函数指针是在运行时创建的，它指向对象的虚函数表，用于动态绑定和调用正确的虚函数。这种机制使得多态性成为可能，能够在运行时根据对象的实际类型来调用适当的虚函数。

虚函数指针存在虚函数表里面。

## include
#include "filename"：使用双引号表示的头文件包含方式会首先在当前源文件所在目录中搜索要包含的文件。如果在当前目录找不到该文件，则会继续搜索其他系统相关的目录（例如编译器设置的包含路径）。这种形式通常用于包含自定义的头文件。

#include <filename>：使用尖括号表示的头文件包含方式主要用于包含标准库头文件或系统提供的头文件。它会直接在系统的标准目录中搜索要包含的文件

## 内存分配
1. 栈（Stack）：栈是用于存储局部变量、函数参数和函数调用信息的内存区域。栈的特点是具有后进先出（LIFO）的结构，变量的分配和释放是自动进行的。栈上的变量在函数调用结束时自动释放，不需要手动管理内存。栈的大小通常有限，由编译器或操作系统设定。
2. 堆（Heap）：堆用于动态分配内存，存储程序运行时动态创建的对象和数据结构。堆上的内存需要手动分配和释放，通过 new 和 delete（或 new[] 和 delete[]）运算符进行管理。堆上分配的内存可以在程序的不同部分共享和访问，但需要手动确保正确的内存管理，以避免内存泄漏和悬挂指针等问题。
3. 常量区（常量数据段）：常量区用于存储字符串常量、全局常量和静态常量数据。这些数据在编译时就被确定，并且在程序的整个生命周期内保持不变。常量区的数据通常是只读的，不能在运行时修改。
4. 全局/静态区（全局数据段）：全局/静态区用于存储全局变量、静态变量和静态对象。这些数据在程序启动时就被创建，并且在程序的整个生命周期内存在。全局/静态区的数据可以在程序的不同部分共享和访问。注意，是变量，没有常量。
5. 代码区（代码段）：代码区用于存储程序的执行代码。这里存储了可执行文件中的指令和函数代码。代码区通常是只读的，不允许修改。

注意：
就算是常量，也要分是否在局部变量中。  
字符串常量的优化
```cpp
const char* s1 = "hello";
const char* s2 = "hello";
(s1==s2) true;

char *s = "hello" //warning: ISO C++ forbids converting a string constant to ‘char*’
//s 在栈上，“hello"在常量区，但是s1不等于p
```
编译器可能对字符串常量进行优化，使其存储在其他地方。一种常见的优化是将短字符串常量存储在程序的只读代码段（text segment）中，而不是常量区。这样可以减少常量区的大小，并且在访问字符串常量时可以直接使用指针  

## static关键字的作用是什么
下面是一些 static 关键字的常见用途和作用：

1. 静态变量（Static Variables）：static 关键字可以用来声明静态变量，这些变量在程序的生命周期内只被初始化一次，不会随着函数的调用而重复初始化。静态变量存储在静态存储区，可以在函数内部、类内部或文件作用域中使用。
2. 静态函数（Static Functions）：static 关键字可以用来声明静态函数，这些函数只能在当前文件内部访问，不能被其他文件调用。静态函数没有 this 指针，因此不能访问非静态成员变量和非静态成员函数。
3. 类的静态成员变量（Static Class Members）：在类内部，static 关键字可以用来声明静态成员变量，这些变量属于类本身而不是类的实例。静态成员变量在所有类的实例之间共享，只有一个副本存在。
4. 类的静态成员函数（Static Class Members）：static 关键字还可以用来声明类的静态成员函数，这些函数属于类本身而不是类的实例。静态成员函数不需要通过类的实例来调用，可以直接使用类名和作用域解析运算符来调用。
5. 文件作用域（Static at File Scope）：在文件的顶层范围内使用 static 关键字可以限制变量或函数的作用域为当前文件内部，使其对其他文件不可见。

## 引用和指针的区别
1. 定义和初始化：指针可以被定义为一个变量，用于存储某个对象的内存地址。而引用是一个已存在对象的别名，必须在定义时进行初始化，并且一旦初始化后，它将一直引用同一个对象，无法改变引用的目标。
2. 空值（null）：指针可以具有空值（nullptr），表示指针不指向任何有效的对象。而引用在定义时必须初始化，并且不能引用空值。
3. 重新赋值：指针可以被重新赋值，可以指向不同的对象。而引用一旦初始化后，不能改变引用的目标，无法重新赋值。
4. 指向的对象：指针可以指向不同类型的对象，也可以指向空间的一部分（如数组元素）。而引用只能引用同一类型的对象，且不能引用空间的一部分。
5. 空间占用：指针本身占据一定的内存空间，通常是指针大小（如4字节或8字节）的内存。而引用不占用额外的内存空间，它只是作为对象的别名。
6. 空间操作：通过指针可以对指针本身进行操作，如指针运算、指针的递增和递减等。而引用没有自己的地址，因此无法对引用本身进行操作。
7. 空间安全性：指针可以为野指针（指向无效或已释放的内存），使用野指针可能导致未定义行为。而引用必须在初始化时指向有效的对象，因此引用相对更安全，不容易出现悬挂指针问题。
8. 引用只能一级，指针可以多级。

## 堆栈溢出一般是由什么原因导致的
栈溢出：
1. 递归调用：递归函数在每次递归调用时会将一些数据（例如函数参数和局部变量）压入栈中，以便在每个递归层级上保持状态。如果递归深度过大，栈空间可能会耗尽，导致堆栈溢出。
2. 过多的局部变量：如果函数中有大量的局部变量，尤其是占用大量内存空间的变量，会消耗大量的栈空间。当栈空间不足以容纳所有局部变量时，就会发生堆栈溢出。
3. 无限递归或循环：如果存在无限递归或循环，导致函数不断调用而没有终止条件或退出机制，栈空间会耗尽，导致堆栈溢出。
4. 大量的函数调用：如果程序中存在大量的函数调用，每个函数调用都会在栈中创建一帧，包含函数参数、返回地址和局部变量等信息。如果函数调用层级过深或函数调用链过长，栈空间可能会耗尽。
5. 缓冲区溢出：在函数内部使用局部数组或缓冲区时，如果写入超过其容量的数据，可能会覆盖栈中其他数据，导致堆栈溢出。
6. 大对象或大数据结构：如果在栈上分配大量的对象或大型数据结构，会消耗大量的栈空间，当栈空间不足以容纳这些对象时，就会发生堆栈溢出。
7. 编译器或操作系统限制：有些编译器或操作系统对栈的大小有限制，当超过限制时，会触发堆栈溢出。

堆溢出通常由以下原因之一导致：
1. 内存分配错误：当向堆申请内存时，如果没有正确计算或估计所需的内存大小，申请的内存块可能会比实际需要的更大。如果在分配的内存块中写入超过其边界的数据，就会导致堆溢出。
2. 缓冲区溢出：在堆上分配的缓冲区或数组，如果写入超过其容量的数据，就会导致堆溢出。这种情况通常发生在没有正确检查输入数据长度或没有进行边界检查的情况下。
3. 使用已释放的内存：当程序使用已经释放的堆内存时，可能会导致堆溢出。这可能发生在释放了内存但仍然保留了指向该内存的指针，并且在后续的操作中继续使用该指针。

## 什么函数不能声明为虚函数
构造函数

## 局部变量可以和全局变量重名
使用::可以访问全局变量

## 如何引用已经定义的的全局变量
引用头文件或者 extern

## 全局变量可不可以定义在被多个.cpp文件包含的头文件
可以但是必须是static。否则重定义，关于这个问题，详情看c++.md

## static函数与普通函数  
1. 可见性：普通函数默认情况下具有外部链接（external linkage），可以在其他文件中使用。而静态函数具有内部链接（internal linkage），只能在当前文件中使用，对其他文件不可见。

2. 生命周期：普通函数的生命周期与程序的执行周期无关，可以在任何时候调用。而静态函数的生命周期与程序的执行周期相同，只能在编译单元的生命周期内调用。

3. 命名冲突：普通函数的名称必须是唯一的，否则会发生符号冲突错误。而静态函数可以在不同的编译单元中具有相同的名称，不会发生冲突。

4. 访问权限：普通函数可以访问和修改类的非静态成员变量和非静态成员函数。而静态函数只能访问和修改类的静态成员变量和静态成员函数。

5. this指针：普通函数会自动获得一个隐含的this指针，指向调用该函数的对象实例，可以通过this指针访问对象的成员。而静态函数没有this指针，无法访问非静态成员。

6. 内存分配：普通函数不会分配额外的内存，只在调用时创建函数栈帧。而静态函数也不会分配额外的内存，但是可以访问静态数据。


## static局部变量和普通的
static局部变量只被初始化一次，下次调用是上次的值。还有作用域

## stack heap
分配方式：在内存中，栈是自动分配和释放内存的，由编译器和操作系统负责管理。它使用一种称为"先进后出"（LIFO，Last-In-First-Out）的方式进行内存分配和释放。堆则是通过动态分配来管理内存，需要显式地请求内存分配和释放，通常使用函数如malloc()、new来分配内存，以及free()、delete来释放内存。

内存管理：栈的内存管理是自动的，当函数调用时，会在栈上为局部变量、函数参数和函数调用信息（返回地址等）分配内存，当函数返回时，栈上的内存会自动释放。而堆的内存管理则需要手动进行，程序员负责在适当的时候申请堆内存，并在使用完毕后显式释放，否则可能会导致内存泄漏。

内存大小：栈的大小通常是固定的，由操作系统或编译器预先设定，一般较小。堆的大小通常比较大，取决于系统的可用内存大小。

内存分配速度：栈的内存分配速度比堆快，因为栈只需要简单地移动指针来分配和释放内存。而堆的内存分配则需要更复杂的算法来搜索合适的内存块。

对象生命周期：栈上的对象的生命周期与其所在的作用域相关，当作用域结束时，对象会自动被销毁。而堆上的对象的生命周期由程序员控制，需要显式地释放内存。

数据共享和访问：栈上的数据只能在其作用域内访问，无法在作用域外共享。而堆上的数据可以通过指针在不同的作用域或函数之间共享和访问。

## 什么是预编译
在C++中，预编译阶段主要包括以下几个方面的处理：

头文件包含（Header Inclusion）：预编译阶段会将源代码中的#include指令解析并将相应的头文件内容插入到源代码中。这样做的目的是将头文件中的声明和定义合并到源代码中，以便在编译时能够正确地处理相关的符号和类型。

宏替换（Macro Expansion）：预编译阶段会对源代码中的宏进行替换。宏是一种文本替换机制，使用#define指令定义。预处理器会按照宏定义的规则将源代码中的宏名称替换为相应的宏定义内容。

条件编译（Conditional Compilation）：预编译阶段会根据条件指令（如#if、#ifdef、#ifndef等）的判断结果选择性地编译或排除部分代码块。这使得程序可以根据条件在不同的编译环境或平台上选择不同的代码路径。

符号定义（Symbol Definition）：预编译阶段可以使用#define指令定义符号常量，这些常量在后续的编译过程中可以被识别和使用。这有助于提高代码的可读性和可维护性。

## const
const在函数中的最前面，参数列表，函数最后面三种情况  
const在指针的 *的前面后面  
const在变量，和对象  
只读  

什么是const关键字？

const是C++中的关键字，用于声明常量。通过使用const关键字，可以将变量声明为只读，其值不能被修改。
const对象和非const对象有什么区别？

const对象是只读对象，其值在初始化后不能被修改。尝试修改const对象的值将导致编译错误。非const对象没有这种限制，可以被修改。
const成员函数和非const成员函数有何区别？

const成员函数声明中使用了const关键字，表示该成员函数不会修改对象的状态。在const成员函数中，不能修改非mutable成员变量，也不能调用非const成员函数，以确保对象的状态不会被修改。非const成员函数没有这种限制。
const指针和指针常量有什么区别？

const指针是指针指向的对象是常量，指针本身可以修改指向其他对象。指针常量是指针本身是常量，指向的对象可以修改。
const引用和非const引用有何区别？

const引用只能绑定到常量对象，不能通过该引用修改对象的值。非const引用可以绑定到非常量对象，并且可以通过该引用修改对象的值。
const和constexpr有何区别？

const用于声明常量，其值在运行时确定。constexpr用于声明常量表达式，其值在编译时就能确定，并且可以用于一些需要编译时常量的上下文，如数组大小、模板参数等。


## volatile

什么是volatile关键字？

volatile是C和C++中的关键字，用于声明变量可能在程序执行期间被意外修改。它告诉编译器不要对该变量进行某些优化，以确保对变量的访问和修改都是按照程序的原始意图进行的。
volatile关键字有什么作用？

volatile关键字用于以下情况：
多线程程序中，当一个变量被多个线程访问时，可以使用volatile关键字来确保对变量的读写操作的可见性。
在嵌入式系统或并行硬件中，用于访问特殊硬件寄存器或外部设备，因为这些寄存器的值可能会在任意时间被修改。
防止编译器对变量进行过度的优化，确保每次访问都是从内存中读取或写入。

为什么使用volatile关键字？

使用volatile关键字的主要原因是为了确保对变量的访问和修改都是按照程序的原始意图进行的。它可以防止编译器进行某些优化，如缓存变量值或重排读写操作的顺序，从而确保对变量的操作是可见的和准确的。

需要注意的是，volatile关键字并不能解决多线程访问共享变量的同步问题，它只是告诉编译器该变量可能会在程序执行期间被修改，而并不提供线程安全性

## 结构体和联合体
结构体（Struct）是一种用户自定义的数据类型，可以将不同类型的数据按照一定的顺序组合在一起，形成一个新的数据结构。结构体的成员可以是不同类型的变量，每个成员可以有自己的名称和数据类型。结构体的定义使用struct关键字，可以通过实例化结构体变量来访问其成员。

联合体（Union）是一种特殊的数据类型，它允许在同一内存空间中存储不同类型的数据，但同一时间只能使用其中一个成员。联合体的成员共享相同的内存空间，所以它们的大小取决于最大的成员。联合体的定义使用union关键字，可以通过实例化联合体变量来访问其成员。

## const和#define
const常量是具有类型和作用域的，而#define定义的常量只是简单的文本替换。  
const常量具有类型检查和类型安全性，而#define定义的常量没有类型检查，可能导致错误。  
const常量具有存储地址，而#define定义的常量没有存储地址，只是简单的文本替换  

## 指针和数组
sizeof(arr) 要分是否是函数参数
sizeof(ptr) 看机器，64位机器上的输出结果不一定是4因为可能是编译器设置

## 如何判断一个程序是c还是c++编译
```cpp
#ifdef __cplusplus

#endif
```

## 用两个栈模拟队列

## 位操作
&（按位与）：对两个操作数的每个对应位执行逻辑与操作，生成一个新的值。  
|（按位或）：对两个操作数的每个对应位执行逻辑或操作，生成一个新的值。  
^（按位异或）：对两个操作数的每个对应位执行逻辑异或操作，生成一个新的值。  
~（按位取反）：对操作数的每个位执行逻辑取反操作，生成一个新的值。  
<<（左移）：将操作数的所有位向左移动指定的位数。  
\>>（右移）：将操作数的所有位向右移动指定的位数。

## 单向链表中在不知道head的情况下删掉自己
```
node = node->next;
node->next = node->next->next;
```

## C和C++ 中的struct
| | protection | 能否定义函数
|--|--|--|
|C | 无 | 否。但函数指针|
|C++ | 有| 可以，默认public|

## C++的class struct
默认访问权限和继承权限

## 函数中传值
值，引用，指针，记住，函数参数是左值。

## 对于短小函数C C++怎么做
C: 宏定义‘
C++： inline

## assert
assert仅在debug版本有用

## new malloc delete free
操作符和函数的区别，以及关于对象的时候，构造和析构

## 动态申请空间的时候，返回NULL
判断是否为NULL，然后终止程序或者设置处理异常函数

## C++是不是类型安全
不是，可以强制转换

## 不用sizeof 判断是否是16还是32位
```cpp
int a = ~0;
if(a>65536) 32
```

## 浮点数运算中涉及相等的时候，应该是看是否在一个范围内。

## 父类写了一个virtual，子类默认会加上的，所以可以不写

## 面对对象的三大特征
面向对象编程（Object-Oriented Programming，简称OOP）有三个主要特征，它们是：

封装（Encapsulation）：

封装是将数据和操作数据的方法（函数）组合在一起形成类（Class），并且对外部隐藏了数据的具体实现细节，只暴露必要的接口供其他对象进行交互。通过封装，可以实现数据的保护和隐藏，提高代码的可维护性和安全性。

继承（Inheritance）：

继承是一种通过已存在的类（父类或基类）创建新类（子类或派生类）的机制。子类可以继承父类的属性和方法，并且可以扩展、修改或重写它们。继承可以实现代码的重用和扩展，提高代码的可维护性和可扩展性。

多态（Polymorphism）：

多态是指同一个接口（函数名）可以具有多种不同的实现方式。通过多态，可以通过基类指针或引用调用派生类的方法，实现动态绑定和运行时多态性。多态提高了代码的灵活性和可扩展性，使得代码更具可读性和可维护性。

## 重载，重写，重定义
重载：
重定义和重写主要是是否多态virtual

## sizeof一个空类
根据C++的标准规定，空类的大小不能为零。这是因为每个实例都应该在内存中具有唯一的地址，以便于区分不同的对象。为了实现这一点，编译器在分配空类的内存空间时，会为其分配一个字节的空间，以确保每个实例都有唯一的地址。

## 全局变量的初始化就不是main函数引起的

## 内联函数在编译时要做类型检查

## 运算符重载的问题
在C++中，有一些运算符是不能被重载的。以下是不能被重载的运算符列表：

成员访问运算符：

.（点运算符）：用于访问类的成员变量和成员函数。
.*（指针成员访问运算符）：用于通过指针访问类的成员变量和成员函数。
范围解析运算符：

::（双冒号）：用于访问命名空间、类的静态成员和嵌套类。
条件运算符：

?:（三元条件运算符）：用于条件选择。
sizeof 运算符：

sizeof：用于获取对象或类型的大小（以字节为单位）。
类型转换运算符：

static_cast
dynamic_cast
const_cast
reinterpret_cast

## c风格的字符串有一个额外的'\0'

## 不使用临时变量交换两个数
```cpp
a = a + b;
b = a - b;
a = a - b;
```

## i+++b
i++优先级高

## cout<<(true : 1 : "1")<<endl;
？后面必须类型一致

## 构造函数里面调用构造函数不能委托构造，而是创建了一个新的对象，因此是在初始化列表里面委托构造

## (++a) = a;(a++) = a;
(a++) = a; error

## 谈谈return
不能返回栈内存的指针和引用  
如果返回的是对象，要考虑效率。  
搞清楚返回的是值还是引用还是指针

## cout一个字符指针会打印字符串而不是地址

## 代码题
```cpp
inline void Max(int val1, int val2)
{
    cout<<(val1 > val2) ? val1:val2;
}
```
输出结果都是0;因为<<优先级大于 : ?


## 编程题
1. 输入一个字节判断置为1的个数。不断右移与1相与
2. 进制转换，就是整除取模，乘法向加这两对逆运算。高转低可以从左到右遍历也可以重右到左。

## a&(a-1)
在C++中，表达式 a & (a-1) 经常用于一种常见的位操作技巧，用于判断一个整数 a 是否为 2 的幂。

这个技巧的关键在于二进制表示。对于一个 2 的幂次方整数，它的二进制表示中只有一个位是1，其他位都是0。例如，2 的幂次方整数的二进制表示为 100、1000、10000 等。

当对一个 2 的幂次方整数 a 进行 a & (a-1) 运算时，会将 a 的二进制表示中的最低位的1变为0，而保持其余位不变。因此，如果 a 是 2 的幂次方整数，那么 a & (a-1) 的结果将为0。

基于这个特性，可以通过判断 a & (a-1) 是否为0，来判断一个整数 a 是否为 2 的幂次方。如果结果为0，则 a 是 2 的幂次方；否则，不是。




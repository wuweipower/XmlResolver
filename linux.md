# linux
##  内核
内核主要负责  
1. 系统内存管理  
2. 软件程序管理
3. 硬件设备管理
4. 文件系统管理

### 系统内存管理
内核通过硬盘上称为交换空间(swap space)的存储区域来实现虚拟内存。内核在交换空间
和实际的物理内存之间反复交换虚拟内存中的内容。这使得系统以为自己拥有比物理内存更多的
可用内存。  

内存被划分为若干块,这些块称作页面(page)。内核会将每个内存页面置于物理内存或交
换空间中。然后,内核会维护一张内存页面表,指明哪些页面位于物理内存,哪些页面被交换到
了磁盘。  

内核会记录哪些内存页面正在使用中,自动把一段时间未访问的内存页面复制到交换空间区
域(称之为换出,swapping out)——即使还有内存可用。当程序要访问一个已被换出的内存页面
时,内核必须将物理内存中的另一个页面换出来为其腾出空间,然后从交换空间换入(swapping in)所请求的页面。  

### 软件程序管理
Linux 操作系统称运行中的程序为进程。  
内核创建了第一个进程(称为 init 进程)来启动系统中所有其他进程。当内核启动时,它会
将 init 进程载入虚拟内存。内核在启动其他进程时,会在虚拟内存中给新进程分配一块专有区域
来存储该进程用到的数据和代码。  
在 Linux 中,有多种 init 进程实现,目前最流行的是以下两种。  
1. SysVinit
2. systemd

### 硬件设备管理
任何 Linux 系统需要与之通信的设备都必须在内核代码中加入
其驱动程序。驱动程序相当于应用程序和硬件设备的“中间人”,允许内核同设备之间交换数据。
向 Linux 内核中插入设备驱动的方法有两种。  
- 将驱动程序编译入内核
- 将设备驱动模块加入内核

以前,插入设备驱动程序的唯一途径就是重新编译内核,开发人员提出了内核模块的概念,允许在无须重新编译内核的情况下将驱动程序插入运行中
的内核。

Linux 系统将硬件设备视为一种特殊文件,称为设备文件  
- 字符设备文件
- 块设备文件
- 网络设备文件

1. 字符设备文件对应于每次只能处理一个字符的设备,大多数类型的调制解调器和终端是作为
字符设备文件创建的。  
2. 块设备文件对应于每次以块形式处理数据的设备,比如硬盘驱动器。  
3. 网络设备文件对应于采用数据包发送和接收数据的设备,这包括网卡和一个特殊的环回设
备,后者允许 Linux 系统使用常见的网络编程协议同自身通信。  

Linux 会为系统的每个设备都创建一种称为“节点”的特殊文件。与设备的所有通信都是通
过设备节点完成的。每个节点都有一个唯一的数值对,以供 Linux 内核标识。数值对包括一个主设备号和一个次设备号。类似的设备会被划分到相同的主设备号下。次设备号用于标识主设备组下的某个特定设备。

### 文件系统管理
ext,ext2,ext3,ext4 是一种文件系统

Linux 内核采用虚拟文件系统(virtual file system,VFS)作为和各种文件系统交互的接口。这为 Linux 内核与其他类型文件系统之间的通信提供了一个标准接口。当文件系统被挂载和使用时,VFS 会在内存中缓存相关信息。

# shell
在图形化桌面出现之前,和 Unix 系统交互的唯一方式就是通过 shell 提供的文本命令行界面
(command line interface,CLI)。CLI 只允许输入文本,而且只能显示文本和基本图形输出.

Linux 系统启动时,会自动创建多个虚拟控制台。虚拟控制台是运行在 Linux 系统内存中的
终端会话,虚拟控制台终端的另一种替代方案是使用 Linux 图形化桌面环境中的终端仿真软件包。终端
仿真软件包会在桌面图形化窗口中模拟控制台终端,这个就是我们熟悉的命令行。

# bash shell
bash 手册的使用 man [你自己要查的内容]  
当你使用 man 命令查看命令手册页的时候,其中的信息是由分页程序(pager)来显示的。

分页程序是一种实用工具,能够逐页(或逐行)显示文本。你可以单击空格键进行翻页,或是使
用 Enter 键逐行查看。按 q 键退出手册页  

如果想使用多个命令选项,那么通常可以将其合并在一起。例如,要使用选项 -a 和
-b ,可以写作 -ab 。  

如果不记得命令名了,可以使用关键字来搜索手册页。语法为 man -k keyword

除了按照惯例命名的各段,手册页中还有不同的节。每节都分配了一个数字,从 1 开始,一
直到 9.

Linux 的路径中不使用驱动器盘符,Windows 会为每个物理磁盘分区分配一个盘符,每个分区都有自己的目录结构,用于访问存储在其中的文件。

Linux 则采用另一种方式。Linux 会将文件存储在名为虚拟目录(virtual directory)的单个目
录结构中。虚拟目录会将计算机中所有存储设备的文件路径都纳入单个目录结构。Linux 虚拟目录结构只包含一个称为根(root)目录的基础目录。根目录下的目录和文件会按照其访问路径一一列出.**要注意的是,路径本身并没有提供任何有关文件究竟存放在哪个物理磁盘中的信息。**

Linux 虚拟目录中比较复杂的部分是它如何来协调管理各个存储设备。我们称在 Linux 系统
中安装的第一块硬盘为根驱动器。根驱动器包含了虚拟目录的核心,其他目录都是从那里开始构建的。

**Linux 会使用根驱动器上一些特别的目录作为挂载点(mount point)。挂载点是虚拟目录中分配给额外存储设备的目录。**
Linux 会让文件和目录出现在这些挂载点目录中,即便它们位于其他物理驱动器中。

系统文件通常存储在根驱动器中,而用户文件则存储在其他驱动器中.

其他硬盘挂载到虚拟目录上
```bash
cd pwd .和..  
ls  
```

```bash
ls -F #用于区别文件和目录 /表示目录，*表示可执行文件
ls -a #显示当前目录下所有文件，包括以.开头的隐藏文件
ls -R #递归选项，列出子目录的所有文件
ls -l #产生长列表格式的输出，显示详细信息
ls -i #要查看文件或目录的 inode 编号
```

在长列表格式输出中，输出的第一行显示了为该目录中的文件所分配的总块数。后面每一个行格式如下  
- 文件类型,比如目录( d )、文件( - )、链接文件( l )、字符设备( c )或块设备( b )
- 文件的权限
- 文件的硬链接数
- 文件属主
- 文件属组
- 文件大小(以字节为单位)
- 文件的上次修改时间
- 文件名或目录名

```bash
touch # 创建空文件
ls 后面接上文件名的匹配模式即可
ls my_*
ls my_?
ls my_func
ls my_[a-i]
ls my_[!a]
```

```bash
cp src dst #如果目标地点有对应文件名，默认覆盖
cp -i src dst #提醒你是否要覆盖
cp one dir/ #会在dir目录下复制one
cp -R Documents/ NewDocuments/ #在执行 cp –R 命令之前,目录 NewDocuments 并不存在。它是随着 cp –R 命令被创建的,
```

**tab键可以命令行补全**

链接文件
- 软链接（符号链接）是一个实实在在的文件,该文件指向存放在虚拟目录结构中某个地方的另一个文件。**这两个以符号方式链接在一起的文件彼此的内容并不相同**。类似windows的快捷方式
  ```bash
  ln -s test_file slink_test_file
  ```

- 硬链接创建的是一个独立的虚拟文件,其中包含了原始文件的信息以及位置。两者就根本而言是同一个文件
  ```bash
  ln test_one hlink_test_one
  #只能对处于同一存储设备的文件创建硬链接。要想在位于不同存储设备的文件之间创建
  链接,只能使用符号链接。
  ```

在 Linux 中,重命名文件称为移动(moving),也可以移动文件  
```bash
mv from to
```

删除
```bash
rm -i file #-i 询问是否删除
rm -i f?l # 匹配删除
```

目录
```bash
mkdir dir
mdkir -p dir/subdir #-p 批量创建缺失的父目录
rmdir wrong_dir/ #默认之删除空目录
rm -r dir #删除dir下的文件和目录本身
#对于 rm 命令, -r 选项和 -R 选项的效果是一样的
```

查看文件类型
```bash
file filename
```

查看文件
```bash
cat file
cat -n file #给所有行加上行号
cat -b file #只给有文本的行加上行号
more file #分页查看，格键向前翻页Enter键逐行向前查看
less file
tail file # 默认最后十行
tail -n num file #显示组后num行
head 同理
head -num #直接在-后面写数字即可
```
</br>

# 更多bash
## 进程
ps只能显示某个时间点的信息
```bash
ps #默认只显示运行在当前终端中属于当前用户的那些进程
ps -ef #-e选项指定显示系统中运行的所有进程; -f 选项则扩充输出内容以显示一些有用的信息列。
ps -l # -l长信息
```
-f后的信息
- UID:启动该进程的用户。
- PID:进程 ID
- PPID:父进程的 PID(如果该进程是由另一个进程启动的)
- C:进程生命期中的 CPU 利用率。
- STIME:进程启动时的系统时间。
- TTY:进程是从哪个终端设备启动的。
- TIME:运行进程的累计 CPU 时间
- CMD:启动的程序名称

-l 选项之后多出的那几列
- F:内核分配给进程的系统标志
- S:进程的状态( O 代表正在运行; S 代表在休眠; R代表可运行,正等待运行; Z 代表僵化,已终止但找不到其父进程; T 代表停止)
- PRI:进程的优先级(数字越大,优先级越低)
- NI:谦让度(nice),用于决定优先级。
- ADDR:进程的内存地址。
- SZ:进程被换出时所需交换空间的大致大小
- WCHAN:进程休眠的内核函数地址。

top可以显示实时情况  

输出的第一部分显示的是系统概况:第一行显示了当前时间、系统的运行时长、登录的用户数以及系统的平均负载。平均负载有 3 个值,分别是最近 1 分钟、最近 5 分钟和最近 15 分钟的平均负载。

第二行显示了进程( top 称其为 task)概况:多少进程处于运行、休眠、停止以及僵化状态(僵化状态指进程已结束,但其父进程没有响应)

下一行显示了 CPU 概况。 top 会根据进程的属主(用户或是系统)和进程的状态(运行、空闲或等待)将 CPU 利用率分成几类输出。

紧跟其后的两行详细说明了系统内存的状态。前一行显示了系统的物理内存状态:总共有多少内存、当前用了多少,以及还有多少空闲。后一行显示了系统交换空间(如果分配了的话)的状态。

最后一部分显示了当前处于运行状态的进程的详细列表  

- PID:进程的 PID。
- USER:进程属主的用户名。
- PR:进程的优先级。
- NI:进程的谦让度。
- VIRT:进程占用的虚拟内存总量。
- RES:进程占用的物理内存总量。
- SHR:进程和其他进程共享的内存总量。
- S:进程的状态( D 代表可中断的休眠, R 代表运行,S 代表休眠, T 代表被跟踪或停止,Z 代表僵化 )
- %CPU:进程使用的 CPU 时间比例。
- %MEM:进程使用的可用物理内存比例。
- TIME+:自进程启动到目前为止所占用的 CPU 时间总量。
- COMMAND:进程所对应的命令行名称,也就是启动的程序名

键入 f 允许你选择用于对输出进行排序的字段,键入 d 允许你修改轮询间隔(polling interval),键入 q 可以退出 top 。

在 Linux 中,进程之间通过信号来通信.
```bash
kill pid #只能通过pid向进程发送term信号，尽可能终止程序
#如果要强行终止，则-s选项指定其他信号（用信号名或信号值）
kill -s HUP pid

pkill process_name #可以使用程序名代替pid，允许使用通配符
```

## 磁盘
在使用新的设备之前，需要将其放在虚拟目录中，这个工作成为挂载（mounting）

如今大部分linux发行版能自动挂载特性类型的可移动存储设备。

在默认情况下, mount 命令会输出当前系统已挂载的设备列表。但是,除了标准存储设备,较新版本的内核还会挂载大量用作管理目的的虚拟文件系统
```bash
mount -t ext4 # 查看ext4 文件系统的信息
mount -t vfat # 查看vfat 文件系统的挂载信息
```

mount名令提供了四部分信息  
- 设备文件名
- 设别在虚拟目录中的挂载点
- 文件系统类型
- 已挂载设备的访问状态

***
以下是手动挂载的命令
```bash
sudo mount -t type device directory 
```
参数type 指定了磁盘格式化所使用的文件系统类型。Linux 可以识别多种文件系统类型。如果与 Windows PC 共用移动存储设备,那么通常需要使用下列文件系统类型。

- vfat:Windows FAT32 文件系统,支持长文件名。
- ntfs:Windows NT 及后续操作系统中广泛使用的高级文件系统。
- exfat:专门为可移动存储设备优化的 Windows 文件系统。
- iso9660:标准 CD-ROM 和 DVD 文件系统

**多数 U 盘会使用 vfat 文件系统格式化。如果需要挂载数据 CD 或 DVD,则必须使用 iso9660**

eg
```bash
mount -t vfat /dev/sdb1 /media/disk
```
一旦存储设备被挂载到虚拟目录,root 用户就拥有了对该设备的所有访问权限,而其他用户
的访问则会被限制

移除可移动设备时,不能直接将设备拔下,应该先卸载
umount 命令支持通过设备文件或者挂载点来指定要卸载的设备
```
umount [directory | device ] 
```

df 命令会逐个显示已挂载的文件系统。与 mount 命令类似, df 命令会输出内核挂载的所有虚拟文件系统,因此可以使用 -t 选项来指定文件系统类型,进而过滤输出结果。

```bash
df -t ext4 -t vfat
```
输出结果如下
- 设备文件位置
- 包含多少以 1024 字节为单位的块
- 使用了多少以 1024 字节为单位的块
- 还有多少以 1024 字节为单位的块可用
- 已用空间所占的百分比
- 设备挂载点

最常用
```bash
df -h # human-readable
```

在默认情况下, du 命令会显示当前目录下所有的文件、目录和子目录的磁盘使用情况,并以磁盘块为单位来表明每个文件或目录占用了多大存储空间
```bash
du
```
行最左侧的数字是每个文件或目录所占用的磁盘块数。注意,这个列表是从目录层级的最底部开始,然后沿着其中包含的文件和子目录逐级向上的。

- -c :显示所有已列出文件的总大小。
- -h :按人类易读格式输出大小,分别用 K 表示千字节、M 表示兆字节、G 表示吉字节。
- -s :输出每个参数的汇总信息。

## 处理数据文件

```bash
sort file # 默认按照字典序排序，而且视数字为字符串
sort -n file # 按照数字排序
sort -m file # 将数字按照月排序
```

在对按字段分隔的数据(比如/etc/passwd 文件)进行排序时, -k 选项和 -t 选项非常方便。先使用 -t 选项指定字段分隔符,然后使用 -k 选项指定排序字段。例如,要根据用户 ID 对/etc/passwd 按数值排序,可以这么做:

```bash
sort -t ':' -k 3 -n /etc/passwd
```
```bash
du -sh * | sort -nr #本例中的管道命令( | )用于将 du 命令的输出传入 sort 命令
# -r 是reverse的意思
```

### 数据搜索
```bash
grep [options] pattern [file]
```
```bash
grep -v t file # -v 输出不匹配的行
grep -n t file # -n 显示匹配指定模式匹配的那些行的行号
grep -c t file # -c count 只想知道多少行含有匹配的模式
grep -e t -e f file # -e 指定多个匹配模式
```

### 数据压缩  
| 工具 | 文件拓展名 |
|  ----  | ----  |
| compress | .Z |
| gzip | .gz
| bzip2 | .bz2|
| xz | .xz|
| zip | .zip |

```
gzip # 用于压缩文件
gzcat # 用于查看压缩过的文本文件的内容。
gunzip #用于解压文件
```

```bash
gzip myfile # 就会把myfile生成为myfile.gz
gzip my* # 就会把所有以my开头的文件分别生成对应的gz 文件
```

### 数据归档

虽然 zip 命令能够很好地将数据压缩并归档为单个文件,但它并不是 Unix 和 Linux 中的标准归档工具。目前,Unix 和 Linux 中最流行的归档工具是 tar 命令。

```
tar function [options] object1 object2 ...
```

function  
| 操作 | 长选项 | 描述 |
|  ----  |  ----  | ---- |
| -A | --concatenate | 将一个tar归档文件追加到另一个tar归档文件末尾 |
| -c | --create | 创建新的 tar 归档文件|
| -r | --append | 将文件追加到 tar 归档文件末尾|
| -x | --extract | 从 tar 归档文件中提取文件 |
|-t | --list | 列出 tar 归档文件的内容|

option
| 选项 | 描述|
| ---- | ---- |
| -C dir | 切换到指定目录 |
| -f file | 将结果输出到文件(或设备) | 
| -v | 在处理文件时显示文件名 |
| -z | 将输出传给 gzip 命令进行压缩 |

eg
```bash
tar -cvf test.tar test/ test2/ # 创建归档文件
tar -tf test.tar #列出了(但不提取)tar 文件 test.tar 的内容。
tar -xvf test.tar # 该命令从 tar 文件 test.tar 中提取内容。如果创建的时候 tar 文件含有目录结构,则在当前目录中重建该目录的整个结构。
tar -zxvf filename.tgz
```

# 理解shell
```bash
which bash # 帮助我们找出bash shell的位置
```
多次在bash里面输入bash其实就是又创建了一个新的进程。

可以在单行中指定要依次运行的一系列命令。这可以通过命令列表来实现,只需将命令之间以分号( ; )分隔即可

```
pwd ; ls test* ; cd /etc ; pwd ; cd ; pwd ; ls my*
```
要想成为进程列表,命令列表必须将命令放入圆括号内:
```bash
(pwd ; ls test* ; cd /etc ; pwd ; cd ; pwd ; ls my*)
```

除了 ps 命令,也可以使用 jobs 命令来显示后台作业信息。 jobs 命令能够显示当前运行在后台模式中属于你的所有进程(作业)
```
jobs
ps -f
```

通过将进程列表置入后台,可以在子 shell 中进行大量的多进程处理。由此带来的一个好处是终端不再和子 shell 的 I/O 绑定在一起。
 
加个&就可以放在后台
```
(sleep 2 ; echo $BASH_SUBSHELL ; sleep 2)&
```

协程
协程同时做两件事:一是在后台生成一个子 shell,二是在该子 shell 中执行命令
```bash
coproc sleep 10
coproc My_Job { sleep 10; } # 设置名字
```
**用扩展语法,协程名被设置成了 My_Job 。这里要注意,扩展语法写起来有点儿小麻烦。你必须确保在左花括号( { )和内部命令名之间有一个空格。还必须保证内部命令以分号( ; )结尾。另外,分号和右花括号( } )之间也得有一个空格。**

## 外部命令与内建命令
### 外部命令
外部命令(有时也称为文件系统命令)是存在于 bash shell 之外的程序。也就是说,它并不属于 shell 程序的一部分。外部命令程序通常位于/bin、/usr/bin、/sbin 或/usr/sbin 目录中。  
可以使用 which 命令和 type 命令找到其对应的文件名

作为外部命令, ps 命令在执行时会产生一个子进程。

### 内建命令
与外部命令不同,内建命令无须使用子进程来执行。内建命令已经和 shell 编译成一体,作为 shell 的组成部分存在,无须借助外部程序文件来执行

可以使用 type 命令来判断某个命令是否为内建
要查看命令的不同实现,可以使用 type 命令的 -a 选项

bash shell 会跟踪你最近使用过的命令。你可以重新唤回这些命令,甚至加以重用。 history是一个实用的内建命令,能帮助你管理先前执行过的命令。

当输入 !! 时,bash 会先显示从 shell 的历史记录中唤回的命令,然后再执行该命令

可以在不退出 shell 的情况下强制将命令历史记录写入.bash_history 文件。为此,需要使用history 命令的 -a 选项:

你可以唤回历史记录中的任意命令。只需输入惊叹号和命令在历史记录中的编号即可:


# linux 环境变量
## 全局变量
全局环境变量对于 shell 会话和所有生成的子 shell 都是可见的。局部环境变量则只对创建它的 shell 可见。如果程序创建的子 shell 需要获取父 shell 信息,那么全局环境变量就能派上用场了。

系统环境变量基本上会使用全大写字母,以区别于用户自定义的环境变量。
```bash
# 查看环境变量
env
printenv 
# 显示个别环境变量的值
printenv HOME
echo $HOME
```
在变量名前加上 $ 可不仅仅是能够显示变量当前的值,它还能让变量作为其他命令的参数


在命令行中查看局部环境变量列表有点儿棘手。遗憾的是,没有哪个命令可以只显示这类变量。 set 命令可以显示特定进程的所有环境变量,既包括局部变量、全局变量,也包括用户自定义变量

设置局部变量
```bash
my_variable=Hello
my_variable="Hello World"
```
如果没有引号,则 bash shell 会将下一个单词( World)视为另一个要执行的命令。

设置全局变量
```
my_variable="I am Global now"
export my_variable
```
在定义并导出变量 my_variable 后, bash 命令生成了一个子 shell。在该子 shell 中可以正确显示出全局环境变量 my_variable 的值。子 shell 随后改变了这个变量的值。但是,这种改变仅在子 shell 中有效,并不会反映到父 shell 环境中。

子 shell 甚至无法使用 export 命令改变父 shell 中全局环境变量的值

删除环境变量
```bash
my_variable="I am going to be removed"
unset my_variable
```

## 设置path环境变量
当你在 shell CLI 中输入一个外部命令时,shell 必须搜索系统,从中找到对应的程序。 PATH 环境变量定义了用于查找命令和程序的目录

只需引用原来的 PATH 值,添加冒号( : ),然后再使用绝对路径输入新目录即可
```bash
PATH=$PATH:/home/christine/Scripts
```

### 环境变量持久化
对全局环境变量(Linux 系统的所有用户都要用到的变量)来说,可能更倾向于将新的或修改过的变量设置放在/etc/profile 文件中,但这可不是什么好主意。如果升级了所用的发行版,则该文件也会随之更新,这样一来,所有定制过的变量设置可就都没有了  

最好在/etc/profile.d 目录中创建一个以.sh 结尾的文件

alias 命令设置无法持久生效。你可以把个人的 alias 设置放在$HOME/.bashrc启动文件中,使其效果永久化。

## 数组变量
要为某个环境变量设置多个值,可以把值放在圆括号中,值与值之间以空格分隔:

```bash
mytest=(zero one two three four)
echo ${mytest[2]}
echo ${mytest[*]}
mytest[2]=seven
unset mytest[2]
```

***
# linux 文件权限

